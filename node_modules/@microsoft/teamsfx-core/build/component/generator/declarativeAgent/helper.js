"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateForMCPForDA = exports.getGraphConnectors = exports.getODSPItemInfo = exports.validateSourcePluginManifest = exports.addExistingPlugin = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const CopilotGptManifestUtils_1 = require("../../driver/teamsApp/utils/CopilotGptManifestUtils");
const PluginManifestUtils_1 = require("../../driver/teamsApp/utils/PluginManifestUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const utils_1 = require("../../driver/teamsApp/utils/utils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../utils/common");
const telemetry_1 = require("../../../common/telemetry");
const error_1 = require("../../../error");
const axios_1 = tslib_1.__importStar(require("axios"));
const constants_1 = require("../../../common/constants");
const oneDriveSharePointHandler_1 = require("./oneDriveSharePointHandler");
const globalVars_1 = require("../../../common/globalVars");
const questionNames_1 = require("../../../question/questionNames");
const logMessageKeys = {
    failValidateOneDriveSharePointItem: "core.createProjectQuestion.log.fail.validateOneDriveSharePointItem",
    invalidOneDriveSharePointURL: "core.createProjectQuestion.log.fail.invalidOneDriveSharePointURL",
};
const pluginManifestPlaceholderWarning = "add-exsiting-plugin-manifest-placehoder";
const apiSpecPlaceholderWarning = "add-exsiting-plugin-api-spec-placehoder";
const readApiSpecErrorTelemetry = "read-api-spec-error";
async function addExistingPlugin(declarativeCopilotManifestPath, fromPluginManifestPath, fromApiSpecPath, actionId, context, source) {
    var _a;
    const pluginManifestRes = await PluginManifestUtils_1.pluginManifestUtils.readPluginManifestFile(fromPluginManifestPath);
    if (pluginManifestRes.isErr()) {
        return (0, teamsfx_api_1.err)(pluginManifestRes.error);
    }
    const pluginManifest = pluginManifestRes.value;
    // prerequiste check
    const checkRes = validateSourcePluginManifest(pluginManifest, source);
    if (checkRes.isErr()) {
        return (0, teamsfx_api_1.err)(checkRes.error);
    }
    const runtimes = pluginManifest.runtimes; // have validated that the value exists.
    const destinationApiSpecRelativePath = runtimes.find((runtime) => runtime.type === "OpenApi")
        .spec.url; // have validated that the value exists.
    const outputFolder = path_1.default.dirname(declarativeCopilotManifestPath);
    // Copy OpenAPI spec
    const originalDestApiSPecRelativePath = path_1.default.resolve(outputFolder, destinationApiSpecRelativePath);
    let destinationApiSpecPath = originalDestApiSPecRelativePath;
    const needUpdatePluginManifest = (await fs_extra_1.default.pathExists(originalDestApiSPecRelativePath)) ||
        path_1.default.relative(outputFolder, originalDestApiSPecRelativePath).startsWith("..");
    if (needUpdatePluginManifest) {
        destinationApiSpecPath = await PluginManifestUtils_1.pluginManifestUtils.getDefaultNextAvailableApiSpecPath(fromApiSpecPath, path_1.default.join(outputFolder, teamsfx_api_1.DefaultApiSpecFolderName));
    }
    await fs_extra_1.default.ensureFile(destinationApiSpecPath);
    await fs_extra_1.default.copyFile(fromApiSpecPath, destinationApiSpecPath);
    // Save plugin manifest
    if (needUpdatePluginManifest) {
        const runtimeSpecUrl = (0, utils_1.normalizePath)(path_1.default.relative(outputFolder, destinationApiSpecPath), true);
        for (const runtime of runtimes) {
            if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
                runtime.spec.url = runtimeSpecUrl;
            }
        }
    }
    const destinationPluginManifestPath = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getDefaultNextAvailablePluginManifestPath(outputFolder);
    await fs_extra_1.default.ensureFile(destinationPluginManifestPath);
    const pluginManifestContent = JSON.stringify(pluginManifest, undefined, 4);
    await fs_extra_1.default.writeFile(destinationPluginManifestPath, pluginManifestContent);
    // Update declarative copilot plugin manifest
    const addActionRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.addAction(declarativeCopilotManifestPath, actionId, (0, utils_1.normalizePath)(path_1.default.relative(outputFolder, destinationPluginManifestPath), true));
    if (addActionRes.isErr()) {
        return (0, teamsfx_api_1.err)(addActionRes.error);
    }
    const warnings = [];
    const pluginManifestVariables = (0, common_1.getEnvironmentVariables)(JSON.stringify(pluginManifest));
    if (pluginManifestVariables.length > 0) {
        warnings.push({
            type: pluginManifestPlaceholderWarning,
            content: (0, localizeUtils_1.getLocalizedString)("core.addPlugin.warning.manifestVariables", pluginManifestVariables.join(", ")),
        });
    }
    try {
        const apiSpecContent = await fs_extra_1.default.readFile(destinationApiSpecPath, "utf8");
        const apiSpecVariables = (0, common_1.getEnvironmentVariables)(apiSpecContent);
        if (apiSpecVariables.length > 0) {
            warnings.push({
                type: apiSpecPlaceholderWarning,
                content: (0, localizeUtils_1.getLocalizedString)("core.addPlugin.warning.apiSpecVariables", apiSpecVariables.join(", ")),
            });
        }
    }
    catch (e) {
        (0, telemetry_1.sendTelemetryErrorEvent)(source, readApiSpecErrorTelemetry, (0, error_1.assembleError)(e));
    }
    return (0, teamsfx_api_1.ok)({
        destinationPluginManifestPath,
        warnings,
    });
}
exports.addExistingPlugin = addExistingPlugin;
function validateSourcePluginManifest(manifest, source) {
    var _a;
    if (!manifest.schema_version) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingSchemaVersion", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "schema_version"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "schema_version")));
    }
    if (!manifest.runtimes) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingRuntimes", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "runtimes"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "runtimes")));
    }
    const apiSpecPaths = new Set();
    for (const runtime of manifest.runtimes) {
        if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
            apiSpecPaths.add(runtime.spec.url);
        }
    }
    if (apiSpecPaths.size === 0) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingApiSpec", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.pluginManifestMissingApiSpec", "OpenApi"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.pluginManifestMissingApiSpec", "OpenApi")));
    }
    if (apiSpecPaths.size > 1) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MultipleApiSpecInPluginManifest", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.pluginManifestMultipleApiSpec", Array.from(apiSpecPaths).join(", ")), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.pluginManifestMultipleApiSpec", Array.from(apiSpecPaths).join(", "))));
    }
    return (0, teamsfx_api_1.ok)(undefined);
}
exports.validateSourcePluginManifest = validateSourcePluginManifest;
async function getODSPItemInfo(context, itemUrl) {
    var _a, _b;
    if (!itemUrl) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("validateOneDriveSharePointItem", "InvalidInput", "Item URL is required"));
    }
    try {
        const graphClientResult = await (0, oneDriveSharePointHandler_1.createGraphClientWithToken)(context);
        if (graphClientResult.isErr()) {
            return (0, teamsfx_api_1.err)(graphClientResult.error);
        }
        const graphClient = graphClientResult.value;
        const siteResult = await (0, oneDriveSharePointHandler_1.getSharePointSiteByRelativePath)(graphClient, itemUrl);
        if (siteResult.isOk()) {
            const site = siteResult.value;
            return (0, teamsfx_api_1.ok)([
                {
                    id: site.id,
                    name: site.name,
                    webId: site.webId,
                    siteId: site.siteId,
                },
            ]);
        }
        const encodedUrl = (0, oneDriveSharePointHandler_1.encodeSharePointUrl)(itemUrl);
        const driveItem = await (0, oneDriveSharePointHandler_1.getDriveItemInfo)(graphClient, encodedUrl);
        return (0, teamsfx_api_1.ok)([
            {
                id: driveItem.id,
                name: driveItem.name,
                uniqueId: driveItem.uniqueId,
                listId: driveItem.listId,
                webId: driveItem.webId,
                siteId: driveItem.siteId,
                itemType: driveItem.itemType,
            },
        ]);
    }
    catch (error) {
        if ((0, axios_1.isAxiosError)(error) && error.response) {
            if (error.response.status >= 400 && error.response.status < 510) {
                (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.error((0, localizeUtils_1.getLocalizedString)(logMessageKeys.failValidateOneDriveSharePointItem, error.message));
                return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("ValidateOneDriveSharePointURL", "GraphApiError", error.message, error.message));
            }
        }
        const message = JSON.stringify(error);
        (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.error((0, localizeUtils_1.getLocalizedString)(logMessageKeys.failValidateOneDriveSharePointItem, message));
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.SystemError("ValidateOneDriveSharePointURL", "GraphApiError", message, message));
    }
}
exports.getODSPItemInfo = getODSPItemInfo;
async function getGraphConnectors() {
    var _a;
    const context = (0, globalVars_1.createContext)();
    const graphTokenRes = await context.tokenProvider.m365TokenProvider.getAccessToken({
        scopes: constants_1.GCScopes,
    });
    if (graphTokenRes.isErr()) {
        throw graphTokenRes.error;
    }
    const graphToken = graphTokenRes.value;
    const instance = axios_1.default.create({
        baseURL: "https://graph.microsoft.com/v1.0",
        headers: { Authorization: `Bearer ${graphToken}` },
    });
    try {
        const res = await instance.get(`/external/connections`);
        const data = res.data;
        const result = data.value.map((item) => {
            return { id: item.id, label: item.id };
        });
        return result;
    }
    catch (error) {
        if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 403) {
            const err = new teamsfx_api_1.UserError("getCopilotConnectors", "GraphApiError", (0, localizeUtils_1.getDefaultString)("core.GCList.insufficientPermission"), (0, localizeUtils_1.getDefaultString)("core.GCList.insufficientPermission"));
            throw err;
        }
        else {
            const message = `Failed to get Copilot connector item: ${error instanceof Error ? error.message : String(error)}`;
            const err = new teamsfx_api_1.UserError("copilotConnectors", "GraphApiError", message, message);
            throw err;
        }
    }
}
exports.getGraphConnectors = getGraphConnectors;
async function generateForMCPForDA(destinationPath, inputs) {
    // 1. Get ai-plugin.json
    const aiPluginFilePath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.DefaultPluginManifestFileName);
    if (!(await fs_extra_1.default.pathExists(aiPluginFilePath))) {
        const error = new teamsfx_api_1.SystemError("MCPForDAPluginManifestNotFound", "PluginManifestNotFound", (0, localizeUtils_1.getDefaultString)("core.MCPForDA.pluginManifestNotFound", aiPluginFilePath), (0, localizeUtils_1.getLocalizedString)("core.MCPForDA.pluginManifestNotFound", aiPluginFilePath));
        return (0, teamsfx_api_1.err)(error);
    }
    const mcpServerUrl = inputs[questionNames_1.QuestionNames.MCPForDAServerUrl];
    const serverName = inputs[questionNames_1.QuestionNames.MCPForDAServerName];
    const mcpTool = inputs[questionNames_1.QuestionNames.MCPForDATool];
    // 2. Read ai-plugin.json
    const aiPluginContent = await fs_extra_1.default.readJSON(aiPluginFilePath);
    // For dynamic fetch tools, keep the functions empty and add runtime info
    if (mcpTool === "dynamic-fetch") {
        aiPluginContent.functions = [];
        aiPluginContent.runtimes = [
            {
                type: "RemoteMCPServer",
                spec: {
                    url: mcpServerUrl,
                    enable_dynamic_discovery: true,
                },
            },
        ];
    }
    else {
        // For pre-fetch tools, add the tool info to ai-plugin.json
        const mcpToolsDetail = inputs[questionNames_1.QuestionNames.MCPForDAAvailableTools];
        const mcpToolsSelected = inputs[questionNames_1.QuestionNames.MCPForDAPreFetchTools];
        const mcpAuth = inputs[questionNames_1.QuestionNames.MCPForDAAuth];
        if (!mcpToolsDetail || !mcpToolsSelected) {
            const error = new teamsfx_api_1.UserError("MCPForDAPreFetchToolsNotFound", "PreFetchToolsNotFound", (0, localizeUtils_1.getDefaultString)("core.MCPForDA.preFetchToolsNotFound"), (0, localizeUtils_1.getLocalizedString)("core.MCPForDA.preFetchToolsNotFound"));
            return (0, teamsfx_api_1.err)(error);
        }
        aiPluginContent.functions = mcpToolsDetail
            .filter((tool) => tool.name.includes(serverName))
            .map((tool) => {
            const index = tool.name.indexOf(serverName);
            const newName = tool.name.substring(index + serverName.length + 1);
            return {
                name: newName,
                description: tool.description,
                inputSchema: tool.inputSchema,
                tags: tool.tags,
            };
        })
            .filter((tool) => mcpToolsSelected.includes(tool.name))
            .map((tool) => {
            return {
                name: tool.name,
                description: tool.description,
                parameters: {
                    type: tool.inputSchema.type || "object",
                    properties: tool.inputSchema.properties,
                    required: tool.inputSchema.required || [],
                },
            };
        });
        aiPluginContent.runtimes = [
            {
                type: "RemoteMCPServer",
                spec: {
                    url: mcpServerUrl,
                    enable_dynamic_discovery: false,
                },
                run_for_functions: aiPluginContent.functions.map((func) => func.name),
            },
        ];
        if (mcpAuth === "OAuthPluginVault") {
            aiPluginContent.runtimes[0].auth = {
                type: "OAuthPluginVault",
                reference_id: "${{MCP_DA_AUTH_ID}}",
            };
        }
    }
    // 3. Write ai-plugin.json
    await fs_extra_1.default.writeJSON(aiPluginFilePath, aiPluginContent, { spaces: 4 });
    return (0, teamsfx_api_1.ok)([]); // Return empty warnings
}
exports.generateForMCPForDA = generateForMCPForDA;
//# sourceMappingURL=helper.js.map